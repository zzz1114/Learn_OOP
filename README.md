[TOC]

# C++面向对象

 面向对象的三大特征：**封装、继承、多态**
 万物皆对象

## 封装：

### 封装的意义1：将属性和行为进行统一

- 将对象的属性和行为作为一个整体，表现一个事物

- 将属性和行为加以权限的控制

    string类型的赋值操作，通过assign来实现，或者直接赋值：

```c
string s1("hello world"), s2;
//s2 = s1;		这样也是可以的 
s2.assign(s1);
```



属性、行为统称为成员	

属性：成员属性.....

行为：成员方法.....



### 封装的意义2：设置访问权限

三种访问权限：

- public          类内可以访问，类外可以访问
- protected   类内可以访问，类外不能访问，子类可以访问
- private        类内可以访问，类外不能访问，子类不能访问

### struct和class的区别

C++中，两者的唯一区别：默认的访问权限不同

- struct默认权限为公共权限public
- class默认权限为私有权限 private

> 不论是属性还是方法，只要没有明确声明权限，默认情况下，在class中都是private的，类外无法访问。在struct中都是public的，在类外可以访问。



## 对象的清理和初始化

### 构造函数和析构函数

#### 构造函数的分类及调用

两种分类方式：

- 按参数分为，有参构造函数和无参构造函数
- 按类型分为，普通构造函数和**拷贝构造函数**

三种调用方式：

- 括号法：

    > ```c
    > Stu stu("张三", 18, "男");   //普通构造函数
    > Stu stu2(stu);				//拷贝构造函数
    > ```

- 显式法：

    > ```c
    > Person person = Person("张三", 18);	//普通构造函数
    > Person person1 = Person(person);	 //拷贝构造函数
    > ```

    > 像Person("张三", 18); 这种对象是**匿名对象**，系统在当前行结束后会立即回收
    >
    > **不要用拷贝构造初始化一个匿名对象**，这样，Person(p)  <==> Person p; 系统会忽略括号，当做重新定义了一个对象p

- 隐式转换法：**转换构造函数**

    > **将一种数据类型转为另一种数据类型**例如将float转为整形：int a = int(1.23)；而对于用户自定义的数据，系统不知道怎么转换 ，就需要定义专门的函数来告诉编译器。
    >
    > **当构造函数只有一个参数**，并且这个参数不是本类的const引用时，这种构造函数就称为转换构造函数
    >
    > ```c
    > Person(string name) : Name(name) {}			//拷贝构造函数
    > ....
    > Person per = "张三";						   //转换构造函数
    > ```
    >
    > 



拷贝构造函数（复制构造函数）：

用于对象间的赋值  类名(类名 &p);			将p的所有属性复制到自身

> 话说为什么要用引用呢？只是复制，根本不会改变源对象的属性

另外，为了防止函数内部对源对象对的异常改变，可以给形参加上const关键字

#### 拷贝构造函数的使用

```c
Stu (const Stu& stu)
{
	Name = stu.getName();
    ...
}
...
    
Stu stu1("张三", 18, "男");

Stu stu2(stu1);
Stu stu3 = stu1;
```

上述两种调用方式虽然形式不同，但是执行的操作完全相同

#### 拷贝构造函数的调用时机

拷贝构造函数在以下三种情况下会被调用：

- 用一个对象初始化另一个对象

    > ```c
    > Person per1("张三", 18, "男");
    > Person per2(per1);
    > ```
    >
    > per2调用了拷贝构造函数

- 用值传递形式给函数参数传值

    > ```c
    > bool cmp(Line l1, Line l2)
    > {
    >     return l1.getLen() > l2.getLen();
    > }
    > .....
    > Line line1((1, 2), (2, 3));
    > Line line2((5, 8), (2, 0));
    > if(cmp(line1, line2));
    > ...
    > ```
    >
    > 这里在调用cmp函数的时候，形参l1  l2会调用拷贝构造函数，将line1和line2的数据拷贝过来

- 以值的方式返回局部对象

    > ```c
    > Point FindIntersection(Line l1, Line l2)//intersection: 交点
    > {
    >     Point intersection;
    > 	.....
    >     return intersection;
    > }
    > ...
    > Point intersection = FindIntersection(line1, line2);
    > ```
    >
    > 因为局部变量在函数FindIntersection结束后就会被系统释放，因此**编译系统会在主函数中创建一个无名的临时变量**，生存期只有函数调用所处的表达式intersection = FindIntersection(line1, line2)中，执行"return intersection"时，会调用**拷贝构造函数**将intersection**拷贝给临时对象**，当函数运行结束时，intersection对象消失，但临时对象会存在于表达式中。
    >
    > > 编译器有时会针对拷贝构造函数的调用做优化，避免不必要的拷贝构造函数调用

#### 深拷贝与浅拷贝

- 浅拷贝：简单的赋值拷贝操作（利用编译器提供的拷贝构造函数，就是浅拷贝）
- 深拷贝：在堆区重新申请内存，进行拷贝操作

浅拷贝带来问题：内存的重复释放

当一个类属性里面有指针，并且在构造函数中为指针申请了内存，在析构函数中释放了这块内存，那个当一个对象拷贝到另一个对象后，**只拷贝了指针**，没有另外申请内存，相当于两个对象的指针指向了同一块内存。当一个对象销毁后，要销毁另一个对象就会出问题，那片内存已经释放了，再次访问就是非法的，程序会崩溃。

> 普通的拷贝构造（或者是默认拷贝构造函数）只会复制所有的属性，一个指针属性也会只把指针复制过去，结果就是两个对象的指针属性都指向了同一块堆内存

**解决办法：**

自己写一个拷贝构造函数，并且另外申请一块堆区内存





### 析构函数

在栈区先进后出，后创建的对象先调用析构

```c
void fun()
{
    Person p1("张三");
    Person p2(p1);
    ...
}
```

则会先调用p2的析构函数，然后调用p1的析构函数

### 类对象作为类成员

```c
class A {};
class B
{
    A a;
};

B b;
```

A 和 B 的构造函数、析构函数的调用顺序是？

> A的构造函数
>
> B的构造函数
>
> B的析构函数
>
> A的析构函数

### 静态成员

在成员变量和成员函数前加上关键字static，称为静态成员

- 静态成员变量

    - 所有对象共享同一份数据
    - 在编译阶段分配内存
    - 类内声明，类外初始化

    ```c
    class A
    {
    public:
        static int value;	//类内声明
        ...
    private:
        static int priva;
    };
    
    int A::value = 1;		//类外初始化
    int A::priva = 3;
    
    A a,  b;
    a.value = 5;
    b.value = 9;
    A::value = 10;
    std::cout << a.value << std::endl;
    //A::priva = 10;	//出错，priva是私有属性
    //a.priva = 10;		//出错，同上
    ```

    先由a修改为5，然后由b修改为9，最后通过类名修改为10

    **也是有权限的**，在private权限下，类外不可直接访问



- 静态成员函数

    - 所有对象共享同一个函数
    - 静态成员函数**只能**访问静态成员

    在函数名前加上static，注意只能访问静态成员变量，调用方式也有两种方式，同静态成员变量；也有访问权限

## 对象模型和this指针

